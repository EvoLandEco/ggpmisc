% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat-quant-line.r
\name{stat_quantile_xy}
\alias{stat_quantile_xy}
\alias{stat_quant_line}
\title{Compute predicted line from quantile regression fit}
\usage{
stat_quantile_xy(
  mapping = NULL,
  data = NULL,
  geom = "quantile",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  n = 80,
  method = "rq",
  method.args = list(),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_quant_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  se = TRUE,
  n = 80,
  method = "rq",
  method.args = list(),
  level = 0.95,
  type = "direct",
  interval = "confidence",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
}
\arguments{
\item{mapping}{The aesthetic mapping, usually constructed with
\code{\link[ggplot2]{aes}} or \code{\link[ggplot2]{aes_}}. Only needs to be
set at the layer level if you are overriding the plot defaults.}

\item{data}{A layer specific dataset, only needed if you want to override
the plot defaults.}

\item{geom}{The geometric object to use display the data}

\item{position}{The position adjustment to use for overlapping points on this
layer}

\item{...}{other arguments passed on to \code{\link[ggplot2]{layer}}. This
can include aesthetics whose values you want to set, not map. See
\code{\link[ggplot2]{layer}} for more details.}

\item{quantiles}{numeric vector Values in 0..1 indicating the quantiles.}

\item{formula}{a formula object. Using aesthetic names \code{x} and \code{y}
instead of original variable names.}

\item{n}{Number of points at which to evaluate smoother.}

\item{method}{function or character If character, "lm", "rlm" and
"rq" are accepted. If a function, it must have formal parameters
\code{formula} and \code{data} and return a model fit object for which
\code{summary()} and \code{coefficients()} are consistent with those for
\code{lm} fits.}

\item{method.args}{named list with additional arguments.}

\item{na.rm}{a logical indicating whether NA values should be stripped before
the computation proceeds.}

\item{orientation}{character Either "x" or "y" controlling the default for
\code{formula}.}

\item{show.legend}{logical. Should this layer be included in the legends?
\code{NA}, the default, includes if any aesthetics are mapped. \code{FALSE}
never includes, and \code{TRUE} always includes.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. \code{\link[ggplot2]{borders}}.}

\item{se}{logical Passed to \code{quantreg::predict.rq()}.}

\item{level}{numeric in range [0..1] Passed to \code{quantreg::predict.rq()}.}

\item{type}{character Passed to \code{quantreg::predict.rq()}.}

\item{interval}{character Passed to \code{quantreg::predict.rq()}.}
}
\value{
The value returned by the statistic is a data frame, that will have
  \code{n} rows of predicted values and and their confidence limits.
}
\description{
Predicted values are computed and, by default, plotted.
\code{stat_quantile_xy()} behaves like \code{\link[ggplot2]{stat_quantile}}
except for supporting the use of \code{y} as explanatory variable in the
model formula.
}
\details{
This statistic is based on \code{\link[ggplot2]{stat_quantile}} updated so
that it interprets the argument passed to \code{formula} differently
accepting \code{y} as well as \code{x} as explanatory variable, matching
\code{stat_poly_quant()}.

When two variables are subject to mutual constrains, it is useful to consider
both of them as explanatory and interpret the relationship based on them. So,
from version 0.4.1 'ggpmisc' makes it possible to easily implement the
approach described by Cardoso (2019) under the name of "Double quantile
regression".


\code{\link[ggplot2]{geom_quantile}}, which is used by default, treats each
axis equally and thus independent of orientation. If no argument is passed
to \code{formula}, it defaults to `y ~ x`.
Package 'ggpmisc' does not define a new geometry matching this statistic
as it is enough for the statistic to return suitable `x` and `y` values.
}
\section{Computed variables}{
 `stat_smooth_xy()` provides the following
  variables, some of which depend on the orientation: \describe{ \item{y *or*
  x}{predicted value} \item{ymin *or* xmin}{lower pointwise confidence
  interval around the mean} \item{ymax *or* xmax}{upper pointwise confidence
  interval around the mean} \item{se}{standard error} }
}

\section{Aesthetics}{
 \code{stat_poly_eq} understands \code{x} and \code{y},
  to be referenced in the \code{formula} and \code{weight} passed as argument
  to parameter \code{weights}. All three must be mapped to \code{numeric}
  variables. In addition, the aesthetics understood by the geom
  (\code{"geom_quantile"} is the default) are understood and grouping
  respected.
}

\examples{
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy()

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line()

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(se = FALSE)

# If you need the fitting to be done along the y-axis set the orientation
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(orientation = "y")

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(orientation = "y")

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(orientation = "y", se = FALSE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(formula = x ~ poly(y, 3))

# Instead of a loess smooth, you can use any other modelling function:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(method = "rqss", se = FALSE)

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  stat_quantile_xy(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quantile_xy(formula = y ~ x) +
  facet_wrap(~drv)

}
\references{
Cardoso, G. C. (2019) Double quantile regression accurately assesses
  distance to boundary trade‚Äêoff. Methods in ecology and evolution, 2019-08,
  10 (8), pp. 1322-1331.
}
